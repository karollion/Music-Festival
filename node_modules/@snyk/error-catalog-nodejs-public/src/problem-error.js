/*
 * Â© 2023 Snyk Limited
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProblemError = void 0;
const types_1 = require("./types");
const uuid_1 = require("uuid");
const util_1 = require("./util");
class ProblemError extends Error {
    constructor(metadata, detail, additionalData, cause) {
        super(metadata.title);
        this.metadata = metadata;
        this.detail = detail;
        this.additionalData = additionalData;
        this.cause = cause;
        // Since `instanceof` cannot be relied upon for class checks in situations where the `ProblemError` was thrown from a dependency of the executing app, we need a more viable solution.
        // See: https://stackoverflow.com/questions/41587865/using-instanceof-on-objects-created-with-constructors-from-deep-npm-dependenci/41592087#41592087
        this.isErrorCatalogError = true;
        if (additionalData && additionalData['overrideErrorId']) {
            this.id = additionalData['overrideErrorId'];
        }
        else {
            this.id = (0, uuid_1.v4)();
        }
    }
    format(instance, formatType) {
        switch (formatType) {
            case types_1.ErrorFormats.JsonApi:
                return this.toJsonApi(instance);
            case types_1.ErrorFormats.ProblemJson:
                return this.toProblemJson(instance);
            default:
                throw new Error('invalid format type');
        }
    }
    toProblemJson(instance) {
        const payload = Object.assign({ type: this.metadata.type, title: this.metadata.title, status: this.metadata.status, errorCode: this.metadata.errorCode, detail: this.detail, instance }, this.additionalData);
        return new types_1.ProblemJson(payload);
    }
    /**
     * Convert this ProblemError to a JsonApiErrorObject.
     * If the error was created with 'instance' metadata then that will be used by default.
     * @param instance string the instance to use for this error. Overrides 'instance' metadata
     * @returns JsonApiErrorObject a JsonApiErrorObject representing this ProblemError
     */
    toJsonApiErrorObject(instance) {
        let source;
        // Get the instance from either the member or the parameter
        const theinstance = instance || this.metadata.instance;
        if (typeof theinstance === 'string') {
            source = (0, util_1.instanceToJsonApiSource)(theinstance);
        }
        const jsonApiErrorObject = {
            id: this.id,
            links: {
                about: this.metadata.type,
            },
            status: String(this.metadata.status),
            code: this.metadata.errorCode,
            title: this.metadata.title,
            detail: this.detail,
            meta: Object.assign({}, this.additionalData),
        };
        if (source) {
            jsonApiErrorObject.source = source;
        }
        return jsonApiErrorObject;
    }
    toJsonApi(instance) {
        const payload = {
            jsonapi: {
                version: '1.0',
            },
            errors: [this.toJsonApiErrorObject(instance)],
        };
        return new types_1.JsonApi(payload);
    }
}
exports.ProblemError = ProblemError;
//# sourceMappingURL=problem-error.js.map