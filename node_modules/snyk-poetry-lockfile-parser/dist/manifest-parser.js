"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependenciesFrom = exports.pkgInfoFrom = void 0;
const toml = require("@iarna/toml");
const error_catalog_nodejs_public_1 = require("@snyk/error-catalog-nodejs-public");
function pkgInfoFrom(manifestFileContents) {
    let manifest;
    try {
        manifest = toml.parse(manifestFileContents);
        return {
            name: manifest.tool.poetry.name,
            version: manifest.tool.poetry.version,
        };
    }
    catch (error) {
        throw new error_catalog_nodejs_public_1.OpenSourceEcosystems.UnparseableManifestError('The pyproject.toml file is not parsable.', { error });
    }
}
exports.pkgInfoFrom = pkgInfoFrom;
function getDependenciesFrom(manifestFileContents, includeDevDependencies) {
    var _a;
    let manifest;
    try {
        manifest = toml.parse(manifestFileContents);
    }
    catch (error) {
        throw new error_catalog_nodejs_public_1.OpenSourceEcosystems.UnparseableManifestError('The pyproject.toml file is not parsable.', { error });
    }
    if (!((_a = manifest.tool) === null || _a === void 0 ? void 0 : _a.poetry)) {
        throw new error_catalog_nodejs_public_1.OpenSourceEcosystems.UnparseableManifestError('The pyproject.toml is not a valid poetry file.');
    }
    const dependencies = dependenciesFrom(manifest).map((dep) => ({
        name: dep,
        isDev: false,
    }));
    const devDependencies = (includeDevDependencies ? devDependenciesFrom(manifest) : []).map((devDep) => ({
        name: devDep,
        isDev: true,
    }));
    return [...dependencies, ...devDependencies].filter((pkg) => pkg.name != 'python');
}
exports.getDependenciesFrom = getDependenciesFrom;
const getGroupDevDepNames = (obj) => {
    const groupDevDepNames = Object.values(obj)
        .map((group) => group.dependencies)
        .map((depsObj) => Object.keys(depsObj))
        .reduce((acc, curr) => [...acc, ...curr], []);
    return groupDevDepNames;
};
function getAllDevDependencyNames(manifest) {
    var _a;
    // pre-v1.2.0 naming convention
    const devDepsProperty = Object.keys((_a = manifest.tool.poetry['dev-dependencies']) !== null && _a !== void 0 ? _a : []);
    // post-v1.2.0 dependency groups
    // https://python-poetry.org/docs/master/managing-dependencies
    // we will handle all tool.poetry.group.<group> as dev-deps
    const groupDevDepsProperty = manifest.tool.poetry.group
        ? getGroupDevDepNames(manifest.tool.poetry.group)
        : [];
    return [...devDepsProperty, ...groupDevDepsProperty];
}
function devDependenciesFrom(manifest) {
    return getAllDevDependencyNames(manifest);
}
function dependenciesFrom(manifest) {
    return Object.keys(manifest.tool.poetry.dependencies || []);
}
//# sourceMappingURL=manifest-parser.js.map